module Transformation;

create OUT : MAPPING  from IN : ECORE, IN2 : ECORE2, RULES : TYPERULES;

--Set of all created matched rules
helper def : allRules : Sequence(MAPPING!Rule) = Sequence{};
--Set of all created helper rules
helper def : allHelper : Sequence(MAPPING!Helper) = Sequence{};
--
helper def : mapping : MAPPING!Mapping = OclUndefined;
--Input mapping
helper def : m_in : MAPPING!Model = OclUndefined;
--Output mapping
helper def : m_out : MAPPING!Model = OclUndefined;
--Constraint mapping
helper def : m_constraint : MAPPING!Model = OclUndefined;

--Input Metamodel name
helper def : mm_in() : String = 'TYPEDUCIF';
--Output Metamodel name
helper def : mm_out() : String = 'TYPEDUCIF';
--Input model name
helper def : m_in_name() : String = 'IN';
--Output model name
helper def : m_out_name() : String = 'OUT';

--ATL keyword helper
helper context String def : atlname : String =
	if self='abstract'
		or self='context'
		or self='helper'
		or self='in'
		or self='uses'
		or self='def'
		or self='if'
		or self='then'
		or self='else'
		or self='endif'
		or self='do'
	then
	'"'+self+'"'
	else
	self
	endif
	;

--Serialize list of strings
helper def : serialize(input : Sequence(String)) : String =
	input->select(s | s.size() > 0)->iterate(c; res : String = ''| if (res = '') 
		                                then c 
										else res + ',' + c endif);

--Classname helper
helper context ECORE!EClass def : sourceName : String =
    
--	'BeanType' ;
	self.name;
helper  def : generateHelperContent(eclass : ECORE!EClass) : String =
	'if invar.oclIsTypeOf('+thisModule.mm_in()+'!"' + eclass.sourceName + '") then \n'
	+'true \n'
	+'else\n'
	+'false\n'
	+'endif\n'
--	 +'\n and invar.class=\'net.swk.workflow.model.activities.ActionContainer\' '
--	 +'\n and thisModule.isAction(invar,\''+eclass.name+'\')'
;

--Once transformation is complete, collect all rules
endpoint rule end(){
	do {
		--thisModule.allRules.debug('');
		--thisModule.allHelper.debug('');

		thisModule.mapping.rules <- thisModule.allRules ;
		thisModule.mapping.helpers <- thisModule.allHelper; --epackage.eClassifiers -> select(e| e.oclIsKindOf(ECORE!EClass)   ) -> select(e|not e."abstract"),

	}
}

--Initialize global variables 
entrypoint rule startup() {

--rule EPackageRule {
--	from epackage : ECORE!EPackage ( epackage.name<>'ecore')
	to mapping : MAPPING!Mapping (
--		rules <- epackage.eClassifiers -> select(e| e.oclIsKindOf(ECORE!EClass)   ) -> select(e|not e."abstract"),
		sources <- modelin,
		--helpers <- thisModule.allRules(),
		targets <- OrderedSet{modelout,modelconstraint}
	 ),
	modelin : MAPPING!Model (
		modelName <- thisModule.m_in_name(),
		metamodelName <- thisModule.mm_in().debug()-- 'INMETAMODEL'
	 ),
	modelout : MAPPING!Model (
		modelName <- thisModule.m_out_name(),
		metamodelName <- thisModule.mm_out().debug()
	 ),
	modelconstraint : MAPPING!Model (
	    modelName <- 'constraint',
		metamodelName <- 'CONSTRAINT'
	),
	--Create variable counter helper
	variablecounter : MAPPING!Helper (
	    name <- 'variablecounter',
		type <- 'Integer',
		content <- '0'
	),
	--Create helper mapping class names to type names
	typemap : MAPPING!Helper (
	    name <- 'typemap',
		type <- 'Map(String,String)',
		content <- 'Map{' + thisModule.serialize(
			                TYPERULES!TypeSystemDec.allInstances().first().typevalues->collect(tv | tv.representation->select(r | r.relation = #In or r.relation = #InOut)->collect(r|'(\'' + r.targetclass.name + '\',\'' + tv.name + '\')')).flatten()
	    	       ) + '}'
	),
	--Create helper mapping model attributes to type attributes
	typeattributemap : MAPPING!Helper (
	    name <- 'typeattributemap',
		type <- 'Map(String,Map(String,String))',
		content <- 'Map{' + 
	    	       thisModule.serialize(
	    	       	            TYPERULES!TypeSystemDec.allInstances().first().typevalues
	    	                    ->collect(tv | thisModule.serialize(tv.representation->select(r | r.relation = #In or r.relation = #InOut)
	    	                    	                                                 ->collect(r | '(\'' + 
	    	                    	                                                               r.targetclass.name + 
	    	                    		       	                                                   '\',Map{' + 
	    	                    		       	                                                   thisModule.serialize(r.attributes->collect(attr | '(\'' + 
	    	                    		       	                              		                                                                  attr.name  + 
																											                                          '\',\'' + tv.attributes.at(r.attributes.indexOf(attr)).name + 
																											                                         '\')'
																								                                              )
																                                                        ) +
																					               '})'					
																				               )
																	)
										  )
				                        ) + 
				  '}'
	),
	--Create helper retrieving variable count
	variablecounterhelper : MAPPING!Helper (
	    name <- 'getVariableNumber',
		type <- 'Integer',
		content <- 'CONSTRAINT!Variable.allInstancesFrom(\'constraint\').count() + 1'
	),
	--Create helper creating feature object based on string parameters
	featurenamer : MAPPING!Helper (
	    name <- 'createFeature3',
		type <- 'CONSTRAINT!Feature',
		parameters <- OrderedSet{featurebaseparameter,featurenameparameter,featurevalueparameter},
		content <- 'thisModule.makeFeature(\'tempfeature\')'+
		           '.refSetValue(\'name\',if (thisModule.typemap.getKeys().includes(base)) then thisModule.typeattributemap.get(base).get(name) else name endif)'+
				   '.refSetValue(\'value\',value.toString())'
	),
	featurebaseparameter : MAPPING!Parameter (
		name <- 'base',
		type <- 'String'
	),	
	featurenameparameter : MAPPING!Parameter (
		name <- 'name',
		type <- 'String'
	),
	featurevalueparameter : MAPPING!Parameter (
		name <- 'value',
		type <- 'ECORE!EObject'
	),
	--Create dault rule for abstract elements
	abstractnoderule : MAPPING!Rule(
		isLazy <- true,
		name <- 'makeNode',
		-- Class origin naming
		sourceClass <- 'Ecore!EObject',
		-- Addition of a variable for the class
		varName <- 'invar',
		-- Addition of the target element defined below
		targetElements <- abstractnodeliteral
	),
	abstractnodeliteral: MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- 'literalvar',
		attributes <- abstractnodeliteralvalue,
		targetModel <- modelconstraint
	),
	abstractnodeliteralvalue : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- '\'error\''
	),
	--Create rule mapping string to literal objects
	literalrule : MAPPING!Rule(
		isLazy <- true,
		name <- 'makeLiteral',
		-- Class origin naming
		sourceClass <- 'Ecore!EString',
		-- Addition of a variable for the class
		varName <- 'invar',
		-- Addition of the target element defined below
		targetElements <- literal
	),
	literal: MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- 'literalvar',
		attributes <- literalvalue,
		targetModel <- modelconstraint
	),
	literalvalue : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- 'if (invar.oclIsKindOf(TYPEDUCIF!EEnumLiteral)) then invar.name else invar.toString() endif'
	),
	--Create rule mapping EObjects to object nodes
	objectrule : MAPPING!Rule(
		isLazy <- true,
		name <- 'makeObjectNode',
		-- Class origin naming
		sourceClass <- 'ECORE!EObject',
		-- Addition of a variable for the class
		varName <- 'invar',
		-- Addition of the target element defined below
		targetElements <- OrderedSet{object}
	 ),
	 object: MAPPING!TargetElement(
	    name <- 'ObjectNode',
		varName <- 'objectvar',
		attributes <- OrderedSet{objectname,objectfeatures},
		targetModel <- modelconstraint
	),
	objectname : MAPPING!ExpressionAttribute(
		name <- 'name',
		value <- 'invar.eClass().eContainer().name + \'_\' + invar.eClass().name'
	),
	objectfeatures : MAPPING!ExpressionAttribute(
		name <- 'features',
		value <- 'invar.eClass().eAllAttributes->select(c | invar.eGet(c) <> OclUndefined)->collect(a | thisModule.createFeature(invar.eClass().name,a.name,thisModule.makeLiteral(invar.eGet(a))))
		          .union(
		          invar.eClass().eAllReferences->select(c | invar.eGet(c) <> OclUndefined and c.name <> \'links\')->collect(a | thisModule.createFeature(
		          	                                                                                                  invar.eClass().name,
																													  a.name,
																													  if (a.upperBound = 1) then
																													      thisModule.makeObjectNode(invar.eGet(a))
																													  else
																													  	  thisModule.makeListNode(invar.eGet(a)->collect(v | thisModule.makeObjectNode(v)))
																													  endif
																													  )
																						            )
				  )'         
	),
	--Rule creating feature based on name and EObject value
	featurerule : MAPPING!Rule(
		name <- 'createFeature',
		-- Class origin naming
		sourceClass <- 'String',
		-- Addition of a variable for the class
		varName <- 'base',
		parameters <- OrderedSet{baseparameter,nameparameter,invalueparameter},
		-- Addition of the target element defined below
		targetElements <- OrderedSet{feature}
	),
	baseparameter : MAPPING!Parameter(
		name <- 'base',
		type <- 'String'
	),	
	nameparameter : MAPPING!Parameter(
		name <- 'name',
		type <- 'String'
	),
	invalueparameter : MAPPING!Parameter(
		name <- 'invalue',
		type <- 'ECORE!EObject'
	),
	feature: MAPPING!TargetElement(
	    name <- 'Feature',
		varName <- 'featurevar',
		attributes <- OrderedSet{featurename,featurevalue},
		targetModel <- modelconstraint
	),	
	featurename : MAPPING!ExpressionAttribute(
		name <- 'name',
		value <- 'name'
	),
	featurevalue : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- 'invalue'
	),
	--Rule creating list node based sequence of EObjects
	listrule : MAPPING!Rule(
		isLazy <- true,
		name <- 'makeListNode',
		-- Class origin naming
		sourceClass <- 'Sequence(ECORE!EObject)',
		-- Addition of a variable for the class
		varName <- 'invar',
		-- Addition of the target element defined below
		targetElements <- OrderedSet{list}
	 ),
	 list: MAPPING!TargetElement(
	    name <- 'ListNode',
		varName <- 'listvar',
		attributes <- OrderedSet{listelements},
		targetModel <- modelconstraint
	),
	listelements : MAPPING!ExpressionAttribute(
		name <- 'values',
		value <- 'invar'
	),
	--Helper retrieving nearest parent of given type
	getcontainer : MAPPING!Helper(
	    name <- 'getContainer',
		type <- 'ECORE!EObject',
		parameters <- OrderedSet{getcontainerobject,getcontainerparent},
		content <- 'if object.oclIsUndefined() then OclUndefined else if object.eClass().name = parent then object else thisModule.getContainer(object.eContainer(),parent) endif endif'
	),
	getcontainerobject : MAPPING!Parameter(
	    name <- 'object',
		type <- 'ECORE!EObject'
	),	
	getcontainerparent : MAPPING!Parameter(
	    name <- 'parent',
		type <- 'String'
	)
	 do{
		--epackage.debug('');
		--epackage.eClassifiers.debug('classifiers');
		--thisModule.allRules.debug('');
		thisModule.mapping <- mapping;
		thisModule.m_in <- modelin;
		thisModule.m_out <- modelout;
		thisModule.m_constraint <- modelconstraint;
		--Add created rules to global collections
		thisModule.allHelper <- thisModule.allHelper.append(variablecounter).append(variablecounterhelper).append(featurenamer).append(typemap).append(typeattributemap).append(getcontainer);
		thisModule.allRules <- thisModule.allRules.append(abstractnoderule).append(literalrule).append(objectrule).append(featurerule).append(listrule);
	}
}

--Helper retrieving set of all attributes to compute
helper def : allFunctions : OrderedSet(String) = TYPERULES!TypeRule.allInstances()->collect(r | r.target.attributes->collect(a | a.myattribute.name)).flatten().asOrderedSet();

--Rule handling classes that have no associated type system rule
rule EClassRuleFromNoConstraint {
	from eclass : ECORE!EClass (
		if eclass.oclIsKindOf(ECORE!EClass) then not eclass."abstract" else false endif
		and eclass.ePackage.name<>'ecore'
		--and eclass.ePackage.name<>'AbstractActivity'
		and eclass.ePackage.name<>'beans'
		and eclass.ePackage.name<>'type'
		--Works! Qualified name would be better!
		and not TYPERULES!TypeRule.allInstances()->exists(tr | tr.source.baseclass.name = eclass.name)
		and not TYPERULES!TypeSystemDec.allInstances()->exists(ts | (ts.baseclass.name = eclass.name) or (eclass.getESuperTypes()->exists(t | t.name = ts.baseclass.name)))

	)
	to r : MAPPING!Rule (
		-- Rule naming
		name <- eclass.name + 'Rule',
		-- Addition of a guard
		guard <- 'thisModule.'+eclass.name + 'Guard(invar)',
		-- Class origin naming
		sourceClass <- eclass.sourceName,--eclass.name,
		-- Addition of a variable for the class
		varName <- 'invar',
		-- get the reference of the modelin model defined in a previous rule
		sourceModel <- thisModule.m_in, --resolveTemp(eclass.ePackage, 'modelin'),
		-- Addition of the target element defined below
		targetElements <- targetElement
	 ),
	 -- build the same target element as the source element in the target model
	targetElement : MAPPING!TargetElement (
		-- the name is the same as the source element name
		name <- eclass.name,

		varName <- eclass.name + 'var',
		attributes  <- eclass.eAllAttributes->
			select(a | a.eAttributeType.toString() <> 'IN!EFeatureMapEntry' and a.changeable)
			->union(eclass.eAllReferences
			-> select(r| r.changeable).flatten()
			)->collect(a | thisModule.makeSourceAttribute(a)
			),
		-- get the reference of the modelout model defined in a previous rule
		targetModel <- thisModule.m_out --resolveTemp(eclass.ePackage, 'modelout')
	 ),
	 --Helper describing guard, currently effectively true
	 h : MAPPING!Helper(
	 	--model <- thisModule.resolveTemp(eclass.ePackage, 'modelin'),eclass.name
		content <- thisModule.generateHelperContent(eclass),-- 'invar.oclIsTypeOf('+thisModule.mm_in()+'!' + eclass.sourceName + ')',
		name <- eclass.name + 'Guard',
		--typeModel <- thisModule.m_in,
		type <- 'Boolean',--eclass.name
		parameters <- Parametervar
	 ),
	 Parametervar : MAPPING!Parameter (
		name <- 'invar',
		type <- thisModule.mm_in()+'!"' + eclass.sourceName + '"' -- eclass.name
	 )

	 do{

	 	thisModule.allHelper <- thisModule.allHelper.append(h) ;
	 	thisModule.allRules <- thisModule.allRules.append(r) ;

	 	--eclass.debug('');
	 }
}

--Rule handling base model object without type system rule
rule EClassRuleFromNoConstraintBase{
	from eclass : ECORE!EClass (
		if eclass.oclIsKindOf(ECORE!EClass) then not eclass."abstract" else false endif
		and eclass.ePackage.name<>'ecore'
		--and eclass.ePackage.name<>'AbstractActivity'
		and eclass.ePackage.name<>'beans'
		and eclass.ePackage.name<>'type'
		--Works! Qualified name would be better!
		and not TYPERULES!TypeRule.allInstances()->exists(tr | tr.source.baseclass.name = eclass.name)
		and TYPERULES!TypeSystemDec.allInstances()->exists(ts | (ts.baseclass.name = eclass.name) or (eclass.getESuperTypes()->exists(t | t.name = ts.baseclass.name)))

	)
	using {
		--Initialize local variables
		typesystem : TYPERULES!TypeSystemDec = TYPERULES!TypeSystemDec.allInstances()->any(ts | (ts.baseclass.name = eclass.name) or (eclass.getESuperTypes()->exists(t | t.name = ts.baseclass.name)));
		typerelations : OrderedSet(MAPPING!TargetElement) = typesystem.widening->collect(t | thisModule.makeRelationConstraint(t,'widen', typesystem.widening.indexOf(t).toString()));
        strategyrelations : OrderedSet(MAPPING!TargetElement) = typesystem.strategy->collect(t | thisModule.makeRelationConstraint(t,'strategy', typesystem.strategy.indexOf(t).toString()));
        types : OrderedSet(MAPPING!TargetElement) = typesystem.typevalues->collect(t | thisModule.makeType(t)).flatten();
        sourceclasses : OrderedSet(MAPPING!TargetElement) = ECORE!EClass.allInstancesFrom('IN')->collect(c | thisModule.makeClassStruct(c));
        targetclasses : OrderedSet(MAPPING!TargetElement) = ECORE2!EClass.allInstancesFrom('IN2')->collect(c | thisModule.makeClassStruct(c));
	}
	to
	 r : MAPPING!Rule (
		-- Rule naming
		name <- eclass.name + 'Rule',
		-- Addition of a guard
		guard <- 'thisModule.'+eclass.name + 'Guard(invar)',
		-- Class origin naming
		sourceClass <- eclass.sourceName,--eclass.name,
		-- Addition of a variable for the class
		varName <- 'invar',
		-- get the reference of the modelin model defined in a previous rule
		sourceModel <- thisModule.m_in, --resolveTemp(eclass.ePackage, 'modelin'),
		-- Addition of the target element defined below
		targetElements <- types.append(sourceclasses).append(targetclasses).append(typerelations).append(strategyrelations).prepend(program).prepend(targetElement)
	 ),
	 -- build the same target element as the source element in the target model
	targetElement : MAPPING!TargetElement (
		-- the name is the same as the source element name
		name <- eclass.name,

		varName <- eclass.name + 'var',
		attributes  <- eclass.eAllAttributes->
			select(a | a.eAttributeType.toString() <> 'IN!EFeatureMapEntry' and a.changeable)
			->union(eclass.eAllReferences
			-> select(r| r.changeable).flatten()
			)->collect(a | thisModule.makeSourceAttribute(a)
			),
		-- get the reference of the modelout model defined in a previous rule
		targetModel <- thisModule.m_out --resolveTemp(eclass.ePackage, 'modelout')
	 ),
	 h : MAPPING!Helper(
	 	--model <- thisModule.resolveTemp(eclass.ePackage, 'modelin'),eclass.name
		content <- thisModule.generateHelperContent(eclass),-- 'invar.oclIsTypeOf('+thisModule.mm_in()+'!' + eclass.sourceName + ')',
		name <- eclass.name + 'Guard',
		--typeModel <- thisModule.m_in,
		type <- 'Boolean',--eclass.name
		parameters <- Parametervar
	 ),
	 Parametervar : MAPPING!Parameter (
		name <- 'invar',
		type <- thisModule.mm_in()+'!' + '"' + eclass.sourceName + '"' -- eclass.name
	 ),	
	 --Build constraint program base
	 program : MAPPING!TargetElement(
	    name <- 'Program',
		varName <- 'program',
		targetModel <- thisModule.m_constraint,
		attributes <- OrderedSet{constraintattr,operatorattr,variableattr,typeattr,typeattrattr,objectelementattr}
	),
	constraintattr : MAPPING!ExpressionAttribute(
		name <- 'constraints',
		value <- 'CONSTRAINT!Constraint.allInstances()'
	),
	operatorattr : MAPPING!ExpressionAttribute(
		name <- 'operators',
        value <- 'OrderedSet{' + thisModule.serialize(typesystem.widening->collect(ts | 'widen' + typesystem.widening.indexOf(ts) + thisModule.makeRelationName(ts)))
			                   + if (typesystem.widening.size() > 0 and typesystem.strategy.size() > 0) then ',' else '' endif+
							     thisModule.serialize(typesystem.strategy->collect(ts | 'strategy' + typesystem.strategy.indexOf(ts) + thisModule.makeRelationName(ts)))
							 
                 + '}'        
	),
	variableattr : MAPPING!ExpressionAttribute(
		name <- 'variables',
		value <- 'CONSTRAINT!Variable.allInstances()' 
	),
	typeattr : MAPPING!ExpressionAttribute(
		name <- 'types',
		value <- 'OrderedSet{' 
			     + thisModule.serialize(typesystem.typevalues->collect(ts | ts.name))
			     + if (typesystem.typevalues.size() > 0 ) then ',' else '' endif 
				 + thisModule.serialize(ECORE!EClass.allInstancesFrom('IN')->collect(c | 'class' + c.eContainer().name + c.name))
				 + ','
				 + thisModule.serialize(ECORE2!EClass.allInstancesFrom('IN2')->collect(c | 'class' + c.eContainer().name + c.name))	
	             + '}'
	),
	typeattrattr : MAPPING!ExpressionAttribute(
		name <- 'typeAttribute',
		value <- typesystem.strategytarget->collect(st | thisModule.allFunctions.indexOf(st.name) + 1).toString()
	),
	objectelementattr : MAPPING!ExpressionAttribute(
		name <- 'objectElements',
		value <- thisModule.allFunctions.toString()
	),
	errorattr : MAPPING!ExpressionAttribute(
		name <- 'errorconstraints',
		value <- 'CONSTRAINT!Constraint.allInstances()->select(c | c.name = \'error\')'
	)
    do{
	 	thisModule.allHelper <- thisModule.allHelper.append(h) ;
	 	thisModule.allRules <- thisModule.allRules.append(r) ;
	 }
}

--Rule handling class that do have associated type system rules
rule EClassRuleFromAddConstraint {
	from eclass : ECORE!EClass (
		if eclass.oclIsKindOf(ECORE!EClass) then not eclass."abstract" else false endif
		and eclass.ePackage.name<>'ecore'
		--and eclass.ePackage.name<>'AbstractActivity'
		and eclass.ePackage.name<>'beans'
		and eclass.ePackage.name<>'type'
		--Works! Qualified name would be better!
		and TYPERULES!TypeRule.allInstances()->exists(tr | tr.source.baseclass.name = eclass.name)

	)
	using {
		typerules : Set(TYPERULES!TypeRule) = TYPERULES!TypeRule.allInstances()->select(tr | tr.source.baseclass.name = eclass.name);
        errorrules : Set(TYPERULES!ErrorRule) = TYPERULES!ErrorRule.allInstances()->select(tr | tr.source.baseclass.name = eclass.name);
	}
	to r : MAPPING!Rule (
		-- Rule naming
		name <- eclass.name + 'Rule',
		-- Addition of a guard
		guard <- 'thisModule.'+eclass.name + 'Guard(invar)',
		-- Class origin naming
		sourceClass <- eclass.sourceName,--eclass.name,
		-- Addition of a variable for the class
		varName <- 'invar',
		-- get the reference of the modelin model defined in a previous rule
		sourceModel <- thisModule.m_in, --resolveTemp(eclass.ePackage, 'modelin'),
		-- Addition of the target element defined below
		targetElements <- OrderedSet{targetElement}
		                  .append(thisModule.makeResultAttribute('rule'))
						  .union(thisModule.allFunctions->collect(f | thisModule.makeResultAttribute(f)))
						  .union(typerules->collect(trs | thisModule.makeConstraint(trs,typerules.indexOf(trs)))
						  .union(errorrules->collect(ers | thisModule.makeErrorRuleConstraint(ers,errorrules.indexOf(ers))))).flatten()

	 ),
	 -- build the same target element as the source element in the target model
	targetElement : MAPPING!TargetElement (
		-- the name is the same as the source element name
		name <- eclass.name,

		varName <- eclass.name + 'var',
		attributes  <- eclass.eAllAttributes->
			select(a | a.eAttributeType.toString() <> 'IN!EFeatureMapEntry' and a.changeable)
			    ->union(eclass.eAllReferences-> select(r| r.changeable).flatten())
--				->reject(s | s.name = 'constraintvar')
				->collect(a | thisModule.makeSourceAttribute(a))
--			       .union(thisModule.makeResultAttributeReference())
                 ,
		-- get the reference of the modelout model defined in a previous rule
		targetModel <- thisModule.m_out --resolveTemp(eclass.ePackage, 'modelout')
	 ),
	 h : MAPPING!Helper(
	 	--model <- thisModule.resolveTemp(eclass.ePackage, 'modelin'),eclass.name
		content <- thisModule.generateHelperContent(eclass),-- 'invar.oclIsTypeOf('+thisModule.mm_in()+'!' + eclass.sourceName + ')',
		name <- eclass.name + 'Guard',
		--typeModel <- thisModule.m_in,
		type <- 'Boolean',--eclass.name
		parameters <- Parametervar
	 ),
	 Parametervar : MAPPING!Parameter (
		name <- 'invar',
		type <- thisModule.mm_in()+'!' + '"' + eclass.sourceName + '"' -- eclass.name
	 )

	 do{

	 	thisModule.allHelper <- thisModule.allHelper.append(h) ;
	 	thisModule.allRules <- thisModule.allRules.append(r) ;
        --eclass.debug('');
	 	
	 }
}

--Build expression referring to index of rule used for invar
rule makeResultAttributeReference() {
	to
	    constraintRefAttribute : MAPPING!ExpressionAttribute (
	 	    name <- 'constraintvar',
		    value <-   'invar.constraintvar.number +1' 
	    )
	do {
		OrderedSet{constraintRefAttribute};
	}	
}

--Build expressiong referring to a given computed attribute
rule makeResultAttribute(name : String) {
	 to
	 constraintVariable : MAPPING!TargetElement (
	 	name <- 'Variable',
		varName <- name + 'variablevar',
		attributes <- constraintVariableNumber,
		targetModel <- thisModule.m_constraint
	 ),
	 constraintVariableNumber : MAPPING!ExpressionAttribute (
	 	name <- 'number',
		value <-  'invar.constraintvar.number +'
				+ thisModule.allFunctions.indexOf(name)
	 )
	 do {
	 	constraintVariable;
	 }
}

--Helper computing a unique name for a relation
helper def : makeRelationName(source : TYPERULES!Relation) : String =
	    if source.oclIsTypeOf(TYPERULES!TypeRelation) 
		then source.lhs.target.representation->any(r | r.relation <> #OUT).targetclass.name + source.rhs.target.representation->any(r | r.relation <> #OUT).targetclass.name
		else source.lhs.baseclass.name + source.rhs.baseclass.name
		endif;

--Generic rule for building constraint for a relation with given type and modifier
rule makeRelationConstraint(source : TYPERULES!Relation, type : String, modifier : String) {
    do {
        if source.oclIsTypeOf(TYPERULES!TypeRelation)
		then
        	thisModule.makeTypeRelConstraint(source,type,modifier)
        else 
        	thisModule.makeModelElementRelationConstraint(source,type,modifier)
        endif;
    }	
}

--Rule for building a type constraint for a relation with given type and modifier
rule makeTypeRelConstraint(source : TYPERULES!TypeRelation, type : String, modifier : String) {
	using {
		--Names of elements involved in the relation
		lhsname : String = source.lhs.target.representation->any(r | r.relation <> #OUT).targetclass.name;
	    rhsname : String = source.rhs.target.representation->any(r | r.relation <> #OUT).targetclass.name;
		--local variables involved in relation
		varsleft : OrderedSet(MAPPING!TargetElement) = source.lhs.arguments->collect(e | thisModule.makeLocalVariable(e.value,type+ modifier));
		varsright : OrderedSet(MAPPING!TargetElement) = source.rhs.arguments->collect(e | thisModule.makeLocalVariable(e.value,type+ modifier));
	    vars : OrderedSet(TYPESYSTEM!Variable) = source.lhs.arguments->collect(e | e.value).union(source.rhs.arguments->collect(e | e.value));
	    vartargets : OrderedSet(MAPPING!TargetElement) = vars->collect(v | thisModule.makeLocalVariable(v,type+ modifier));
	    env : Map(String,String) = vars->iterate(v ; baseenv : Map(String,String) = Map{} | baseenv.including(v.varname, type+ modifier + 'variable' + v.varname.substring(2,v.varname.size())));
	    --Constraints representing conditions of relation 
		constraints : OrderedSet(MAPPING!TargetElement) = source.conditions->collect(c | thisModule.ConditionConstraint(c,type + modifier + 'constraint'+ lhsname + rhsname + source.conditions.indexOf(c), type + modifier,env));
	}
	to
	--Main expression object
	    constraint : MAPPING!TargetElement (
	    	name <- 'Operator',
			varName <- type + modifier + lhsname + rhsname,
			attributes <- OrderedSet{opattr,leftattr,rightattr,variableattr,constraintsattr},
			targetModel <- thisModule.m_constraint
	    ),
		opattr : MAPPING!ExpressionAttribute(
			name <- 'name',
			value <- '\'' + type + 'basic\''
		),
		leftattr : MAPPING!ExpressionAttribute(
			name <- 'lhs',
			value <- type + modifier + 'leftvar' + lhsname
		),
		rightattr : MAPPING!ExpressionAttribute(
			name <- 'rhs',
			value <- type + modifier + 'rightvar' + rhsname
		),
	   variableattr : MAPPING!ExpressionAttribute(
	      name <- 'variables',
		  value <- 'OrderedSet{' + thisModule.serialize(vartargets->collect(v | v.varName)) + '}'
	   ),
	   constraintsattr : MAPPING!ExpressionAttribute(
	      name <- 'constraints',
		  value <- 'OrderedSet{' + thisModule.serialize(source.conditions->collect(c | type + modifier + 'constraint'+ lhsname + rhsname + source.conditions.indexOf(c))) + '}'
	   )
		
		do{
			OrderedSet{constraint,thisModule.makeTypeRelationType(source.lhs,type + modifier,'leftvar'),thisModule.makeTypeRelationType(source.rhs,type + modifier,'rightvar'),vartargets,constraints};
		}	
}

--Rule building element represent type involved in relation
rule makeTypeRelationType(source : TYPERULES!TypeRelationReference, type : String, modifier : String) {
	using {
		--Type features
	    features : OrderedSet(MAPPING!TargetElement) = source.arguments->collect(a | thisModule.makeTypeRelationFeature(a,source.target,type,modifier));	
	}
	to
	    target : MAPPING!TargetElement (
	        name <- 'ObjectNode',
			varName <- type + modifier + source.target.representation->any(r | r.relation <> #OUT).targetclass.name,
			attributes <- OrderedSet{nameattr,featureattr},
		    targetModel <- thisModule.m_constraint
			
	    ),
	   nameattr : MAPPING!ExpressionAttribute(
		  name <- 'name',
		  value <- '\'' + source.target.representation->any(r | r.relation <> #OUT).targetclass.name + '\''
	   ),
	   featureattr : MAPPING!ExpressionAttribute(
		  name <- 'features',
		  value <- 'OrderedSet{' + thisModule.serialize(source.arguments->collect(a | type + modifier + a.typeattribute.name)) + '}'
	   )
		
	do {
		OrderedSet{target,features};
	}	    
}

--Rule building element for feature of type involved in relation
rule makeTypeRelationFeature(source : TYPERULES!TypeRelationReferenceElement, type : TYPERULES!TypeDec, base : String, modifier : String) {
	using {
	    attrname : String = type.representation->any(r | r.relation <> #OUT).attributes.at(type.attributes.indexOf(type.attributes->any(ta| ta.name = source.typeattribute.name))).name;
	}
	to
	    target : MAPPING!TargetElement (
	        name <- 'Feature',
			varName <-base + modifier + source.typeattribute.name,
			attributes <- OrderedSet{nameattr,variableattr},
		    targetModel <- thisModule.m_constraint
			
	    ),
	    nameattr : MAPPING!ExpressionAttribute(
		  name <- 'name',
		  value <- '\'' + attrname + '\''
	    ),
	    variableattr : MAPPING!ExpressionAttribute(
		  name <- 'value',
		  value <- base + modifier + attrname + 'var'
	    ),
	    variable : MAPPING!TargetElement (
	        name <- 'VariableReference',
			varName <- base + modifier + attrname + 'var',
			attributes <- variablenameattr,
		    targetModel <- thisModule.m_constraint		
	    )	   ,
	    variablenameattr : MAPPING!ExpressionAttribute(
		  name <- 'var',
		  value <- base + 'variable'+ source.value.varname.substring(2,source.value.varname.size())
	    )		
	do {
		OrderedSet{target,variable};
	}	    
}

--Rule building relation between model elements
rule makeModelElementRelationConstraint(source : TYPERULES!ModelElementRelation, type : String, modifier : String) {
	using {
		--Local variables of relation
		varsleft : OrderedSet(MAPPING!TargetElement) = source.lhs.attributes->collect(e | thisModule.makeLocalVariable(e.variable,type + modifier));
		varsright : OrderedSet(MAPPING!TargetElement) = source.rhs.attributes->collect(e | thisModule.makeLocalVariable(e.variable,type + modifier));
	    vars : OrderedSet(TYPESYSTEM!Variable) = source.lhs.attributes->collect(e | e.variable).union(source.rhs.attributes->collect(e | e.variable));
	    vartargets : OrderedSet(MAPPING!TargetElement) = vars->collect(v | thisModule.makeLocalVariable(v,type+modifier));
	    env : Map(String,String) = vars->iterate(v ; baseenv : Map(String,String) = Map{} | baseenv.including(v.varname, type+ modifier + 'variable' + v.varname.substring(2,v.varname.size())));
	    --Constraints implementing conditions of relation
		constraints : OrderedSet(MAPPING!TargetElement) = source.conditions->collect(c | thisModule.ConditionConstraint(c,type + modifier + 'constraint' + source.conditions.indexOf(c), type + modifier,env)).flatten();
	}
	to
	    constraint : MAPPING!TargetElement (
	    	name <- 'Operator',
			varName <- type + modifier + source.lhs.baseclass.name + source.rhs.baseclass.name,
			attributes <- OrderedSet{opattr,leftattr,rightattr,variableattr,constraintsattr},
			targetModel <- thisModule.m_constraint
	    ),
		opattr : MAPPING!ExpressionAttribute(
			name <- 'name',
			value <- '\'' + type + 'basic\''
		),
		leftattr : MAPPING!ExpressionAttribute(
			name <- 'lhs',
			value <- type + modifier + 'leftvar' + source.lhs.baseclass.name
		),
		rightattr : MAPPING!ExpressionAttribute(
			name <- 'rhs',
			value <- type + modifier + 'rightvar' + source.rhs.baseclass.name
		),
	   variableattr : MAPPING!ExpressionAttribute(
	      name <- 'variables',
		  value <- 'OrderedSet{' + thisModule.serialize(vartargets->collect(v | v.varName)) + '}'
	   ),
	   constraintsattr : MAPPING!ExpressionAttribute(
	      name <- 'constraints',
		  value <- 'OrderedSet{' + thisModule.serialize(source.conditions->collect(c | type + modifier + 'constraint' + source.conditions.indexOf(c))) + '}'
	   )
		
		do{
			OrderedSet{constraint,thisModule.makeModelElementRelationType(source.lhs,type + modifier,'leftvar'),thisModule.makeModelElementRelationType(source.rhs,type + modifier,'rightvar'),vartargets,constraints};
		}	
}

--Rule building element for relation
rule makeModelElementRelationType(source : TYPERULES!RuleElementExpression, type : String, modifier : String) {
	using {
	    features : OrderedSet(MAPPING!TargetElement) = source.attributes->collect(a | thisModule.makeModelElementRelationFeature(a,type,modifier));	
	}
	to
	    target : MAPPING!TargetElement (
	        name <- 'ObjectNode',
			varName <- type + modifier + source.baseclass.name,
			attributes <- OrderedSet{nameattr,featureattr},
		    targetModel <- thisModule.m_constraint
			
	    ),
	   nameattr : MAPPING!ExpressionAttribute(
		  name <- 'name',
		  value <- '\'' + source.baseclass.eContainer().name + '_' + source.baseclass.name + '\''
	   ),
	   featureattr : MAPPING!ExpressionAttribute(
		  name <- 'features',
		  value <- 'OrderedSet{' + thisModule.serialize(source.attributes->collect(a | type + modifier + a.myattribute.name)) + '}'
	   )
		
	do {
		OrderedSet{target,features};
	}	    
}

--Rule building features for relation elements
rule makeModelElementRelationFeature(source : TYPERULES!RuleElementAttribute, type : String, modifier : String) {
	to
	    target : MAPPING!TargetElement (
	        name <- 'Feature',
			varName <- type + modifier + source.myattribute.name,
			attributes <- OrderedSet{nameattr,variableattr},
		    targetModel <- thisModule.m_constraint
			
	    ),
	    nameattr : MAPPING!ExpressionAttribute(
		  name <- 'name',
		  value <- '\'' + source.myattribute.name + '\''
	    ),
	    variableattr : MAPPING!ExpressionAttribute(
		  name <- 'value',
		  value <- type + modifier + source.myattribute.name + 'var'
	    ),
	    variable : MAPPING!TargetElement (
	        name <- 'VariableReference',
			varName <- type + modifier + source.myattribute.name + 'var',
			attributes <- variablenameattr,
		    targetModel <- thisModule.m_constraint		
	    )	   ,
	    variablenameattr : MAPPING!ExpressionAttribute(
		  name <- 'var',
		  value <- type + 'variable'+ source.variable.varname.substring(2,source.variable.varname.size())
	    )		
	do {
		OrderedSet{target,variable};
	}	    
}

--Rule building type representation based on type declaration
rule makeType(source : TYPERULES!TypeDec) {
	to
	    target : MAPPING!TargetElement(
	        name <- 'Type',
			varName <- source.name,
			attributes <- OrderedSet{targetname},
			targetModel <- thisModule.m_constraint
	    ),
		targetname : MAPPING!ExpressionAttribute(
		    name <- 'name',
			value <- '\'' + source.name + '\''
		),
		parametersattr : MAPPING!ExpressionAttribute(
			name <- 'parameters',
			value <- 'OrderedSet{' + thisModule.serialize(source.attributes->collect(p | '\'' + p.name + '\'')) + '}'
		)
	do {
		if (source.attributes.size() > 0)
		    { 
			     target.attributes <- parametersattr;
			     
		    }
		
		target;
		--Sequence{target,identifier};
	}
	
}

--Rule building class declaration
rule makeClassStruct(source : ECORE!EClass) {
	to
	    target : MAPPING!TargetElement(
	        name <- 'Type',
			varName <- 'class' + source.eContainer().name + source.name,
			attributes <- OrderedSet{targetname},
			targetModel <- thisModule.m_constraint
	    ),
		targetname : MAPPING!ExpressionAttribute(
		    name <- 'name',
			value <- '\'' + source.eContainer().name + '_' + source.name + '\''
		),
		parametersattr : MAPPING!ExpressionAttribute(
			name <- 'parameters',
			value <- 'OrderedSet{' + thisModule.serialize(source.eStructuralFeatures->collect(p | '\'' + p.name + '\'').union(source.eSuperTypes->collect(p | '\'p' + source.eSuperTypes.indexOf(p) + ':' + p.eContainer().name + '_' + p.name + '\''))) + '}'
		)
	do {
		if ((source.eStructuralFeatures.size() > 0 or source.eSuperTypes.size() > 0))
		    { 
			     target.attributes <- parametersattr;
			     
		    }
		
		target;
		--Sequence{target,identifier};
	}
	
}

--Lazy rule building mapping attribute based on EAttribute
lazy rule makeSourceAttribute {
    from
	    source : ECORE!EAttribute
	
	to  
	    target : MAPPING!SourceAttribute (
	    	name <- source.name.atlname
	    )
}

--Rule collecting constraints for the identifier and target attributes of a rule.
rule makeConstraints(target : TYPERULES!TypeRule, rank : String){
	using {
		valueconstraints : OrderedSet(MAPPING!TargetElement) = target.target.attributes->collect(attr | thisModule.makeValueConstraint(target,attr,rank)).flatten();
	}
	do {
		valueconstraints <- valueconstraints.union(thisModule.makeIdentifierConstraint(target,rank));
		valueconstraints;
	}
}

--Rule building all constraints for rule target using rank as disambiguation
rule makeConstraint(target : TYPERULES!TypeRule, rank : String){
	    using {
	    	--Identifier of constraint
	    	constraintname : String ='constraint' + TYPERULES!TypeRule.allInstances().indexOf(target) + rank;
	        --Local variables needed
	    	tempvariables : OrderedSet(TYPESYSTEM!Variable) = target.variables.union(target.containments).union(target.source.attributes.union(target.target.attributes->reject(a | target.source.attributes->exists(b | a.variable.varname = b.variable.varname)))->collect(a | a.variable));
	        tempvariabletargets : OrderedSet(MAPPING!TargetElement) = tempvariables->collect(v | thisModule.makeLocalVariable(v,constraintname));
	        --Map linking type system variable names to generated variable names
	        env : Map(String,String) = tempvariables->iterate(v ; baseenv : Map(String,String) = Map{} | baseenv.including(v.varname,constraintname + 'variable' + v.varname.substring(2,v.varname.size())));
	        --Constraints implementing rule conditions
	        temp : OrderedSet(MAPPING!TargetElement) = target.conditions->collect(c | thisModule.ConditionConstraint(c,constraintname + 'constraint' + target.conditions.indexOf(c), constraintname,env)).flatten();
	        --Constraints setting values for local variables based on input model
	        tempinit : OrderedSet(MAPPING!TargetElement) = target.source.attributes->collect(a | thisModule.initLocalVariable(target,a,constraintname,env)).flatten();
	        --Constraints implementing containment conditions
	        tempcontainers : OrderedSet(MAPPING!TargetElement) = target.containments->collect(c | thisModule.makeContainer(target, c, constraintname, env)).flatten();
	        --Constraints implement equations
	        tempequations : OrderedSet(MAPPING!TargetElement) = target.target.attributes->collect(attr | thisModule.makeEquation(constraintname,attr.myattribute.name,attr.variable.varname,rank)).flatten();
	    }
	    to
		--Main rule constraint element
	    constraint : MAPPING!TargetElement (
	    	name <- 'EquationConstraint',
			varName <- constraintname + 'targetrule',
			attributes <- OrderedSet{nameattr,expattr, constrattr,localvarattr},
			targetModel <- thisModule.m_constraint
	    ),
		nameattr : MAPPING!ExpressionAttribute(
			name <- 'name',
			value <- '\'type\''
		),
		--Main constraint equation
		expattr : MAPPING!ExpressionAttribute(
			name <- 'equation',
			value <- 'OrderedSet{' + constraintname + 'varequation' + if (target.target.attributes.size() > 0) then ',' + thisModule.serialize(target.target.attributes->collect(attr | constraintname + attr.myattribute.name + 'varequation')) else '' endif + '}'
		),
		equation :  MAPPING!TargetElement (
			name <- 'Equation',
			varName <- constraintname + 'varequation',
			attributes <- OrderedSet{lefteqattr,righteqattr},
		    targetModel <- thisModule.m_constraint
		),
		--Lefthand-side refers to variable
		lefteqattr : MAPPING!ExpressionAttribute(
			name <- 'left',
			value <- constraintname + 'rulevarref'
		),
		varref : MAPPING!TargetElement(
	        name <- 'VariableReference',
		    varName <- constraintname + 'rulevarref',
		    attributes <- variable,
		    targetModel <- thisModule.m_constraint
	    ),
	    variable : MAPPING!ExpressionAttribute(
	        name <- 'var',
	        value <- 'rulevariablevar'
	    ),
		--Righthand-side defines value
		righteqattr : MAPPING!ExpressionAttribute(
			name <- 'right',
			value <- constraintname + 'expressionvar'
		),
		tempexp : MAPPING!TargetElement(
	        name <- 'Literal',
		    varName <- constraintname + 'expressionvar',
		    attributes <- type,
		    targetModel <- thisModule.m_constraint
	    ),
	    type : MAPPING!ExpressionAttribute(
		    name <- 'value',
		    value <- '\'' + TYPERULES!TypeRule.allInstances().indexOf(target).toString() + '\''
	    ),
		constrattr : MAPPING!ExpressionAttribute(
			name <- 'localconstraints',
			value <- 'OrderedSet{' + thisModule.serialize(target.source.attributes->collect(a | constraintname + a.myattribute.name + 'init').union(target.containments->collect(co | constraintname + co.container.name + 'init')).union(target.conditions->collect(c | constraintname + 'constraint' + target.conditions.indexOf(c))))				  
							    + '}'
		),
		localvarattr : MAPPING!ExpressionAttribute(
		    name <- 'localvariables',
			value <- 'OrderedSet{' + thisModule.serialize(tempvariabletargets->collect(v | v.varName)) + '}'
		)
	do{
		temp <- temp.prepend(varref).prepend(equation).prepend(constraint).union(tempinit).union(tempcontainers).append(tempexp).union(tempvariabletargets);
		temp <- temp.union(tempequations);
        temp;
      }	 
}

--Rule defing constraint for error case
rule makeErrorRuleConstraint(target : TYPERULES!ErrorRule, rank : String){
	    using {
	    	--Identifier of constraint
	    	constraintname : String ='error' + TYPERULES!ErrorRule.allInstances().indexOf(target) + rank;
	        --Local variables
	    	tempvariables : OrderedSet(TYPESYSTEM!Variable) = target.variables.union(target.source.attributes->collect(a | a.variable));
	        tempvariabletargets : OrderedSet(MAPPING!TargetElement) = tempvariables->collect(v | thisModule.makeLocalVariable(v,constraintname));
	        --Map linking type system variables to generated variable names
	        env : Map(String,String) = tempvariables->iterate(v ; baseenv : Map(String,String) = Map{} | baseenv.including(v.varname,constraintname + 'variable' + v.varname.substring(2,v.varname.size())));
	        --Condition constraints
	        temp : OrderedSet(MAPPING!TargetElement) = target.conditions->collect(c | thisModule.ConditionConstraint(c,constraintname + 'constraint' + target.conditions.indexOf(c), constraintname,env)).flatten();
	        --Constraints initializing variables based on input model
	        tempinit : OrderedSet(MAPPING!TargetElement) = target.source.attributes->collect(a | thisModule.initLocalVariable(target,a,constraintname,env)).flatten();
	        --Constraint linking position of error
	        tempposition : OrderedSet(MAPPING!TargetElement) = if(not target.position.oclIsUndefined()) then thisModule.ExpressionConstraint(target.position,constraintname + 'position',constraintname,env) else OrderedSet{} endif;
	    }
	    to
		--Main constraint element
	    constraint : MAPPING!TargetElement (
	    	name <- 'EquationConstraint',
			varName <- constraintname + 'targetrule',
			attributes <- OrderedSet{nameattr,expattr, constrattr,localvarattr},
			targetModel <- thisModule.m_constraint
	    ),
		nameattr : MAPPING!ExpressionAttribute(
			name <- 'name',
			value <- '\'error\''
		),	
		expattr : MAPPING!ExpressionAttribute(
			name <- 'equation',
			value <- 'OrderedSet{' + constraintname + 'varequation' + '}'
		),
		equation :  MAPPING!TargetElement (
			name <- 'Equation',
			varName <- constraintname + 'varequation',
			attributes <- OrderedSet{lefteqattr,righteqattr},
		    targetModel <- thisModule.m_constraint
		),
		--Lefthand-side defines variable reference
		lefteqattr : MAPPING!ExpressionAttribute(
			name <- 'left',
			value <- constraintname + 'rulevarref'
		),
		varref : MAPPING!TargetElement(
	        name <- 'VariableReference',
		    varName <- constraintname + 'rulevarref',
		    attributes <- variable,
		    targetModel <- thisModule.m_constraint
	    ),
	    variable : MAPPING!ExpressionAttribute(
	        name <- 'var',
	        value <- 'rulevariablevar'
	    ),
		--Righthand-side defines error value
		righteqattr : MAPPING!ExpressionAttribute(
			name <- 'right',
			value <- constraintname + 'expressionvar'
		),
		tempexp : MAPPING!TargetElement(
	        name <- 'ObjectNode',
		    varName <- constraintname + 'expressionvar',
		    attributes <- OrderedSet{errorname,errorfeatures},
		    targetModel <- thisModule.m_constraint
	    ),
	    errorname : MAPPING!ExpressionAttribute(
		    name <- 'name',
		    value <- '\'error\''
	    ),
	    errorfeatures : MAPPING!ExpressionAttribute(
		    name <- 'features',
		    value <- 'OrderedSet{' + constraintname + 'messagefeature' + if(not target.position.oclIsUndefined()) then ',' + constraintname + 'positionfeature' else '' endif +'}'
	    ),
		messagefeature : MAPPING!TargetElement(
		    name <- 'Feature',
		    varName <- constraintname + 'messagefeature',
		    attributes <- OrderedSet{messagename,messagevalue},
		    targetModel <- thisModule.m_constraint 	
		),
		messagename : MAPPING!ExpressionAttribute(
		    name <- 'name',
		    value <- '\'message\''
	    ),
		messagevalue : MAPPING!ExpressionAttribute(
		    name <- 'value',
		    value <- constraintname + 'messageliteral'
	    ),
		messageliteral : MAPPING!TargetElement(
	        name <- 'Literal',
		    varName <- constraintname + 'messageliteral',
		    attributes <- messageliteralvalue,
		    targetModel <- thisModule.m_constraint
	    ),
		messageliteralvalue : MAPPING!ExpressionAttribute(
		    name <- 'value',
		    value <- '\'' + target.message + '\''
	    ),
		constrattr : MAPPING!ExpressionAttribute(
			name <- 'localconstraints',
			value <- 'OrderedSet{' + thisModule.serialize(target.source.attributes->collect(a | constraintname + a.myattribute.name + 'init').union(target.conditions->collect(c | constraintname + 'constraint' + target.conditions.indexOf(c))))				  
							    + '}'
		),
		localvarattr : MAPPING!ExpressionAttribute(
		    name <- 'localvariables',
			value <- 'OrderedSet{' + thisModule.serialize(tempvariabletargets->collect(v | v.varName)) + '}'
		)
	do{
		temp <- temp.prepend(varref).prepend(equation).prepend(constraint).union(tempinit).append(tempexp).append(messagefeature).append(messageliteral).union(tempposition).union(tempvariabletargets);
		--temp <- temp.union(tempequations);
		if(not target.position.oclIsUndefined()) { temp <- temp.append(thisModule.makeErrorPositionFeature(constraintname)); }
        temp;
      }	 
}

--Rule creating position feature for a given constraint
rule makeErrorPositionFeature(constraintname : String) {
	to	positionfeature : MAPPING!TargetElement(
		    name <- 'Feature',
		    varName <- constraintname + 'positionfeature',
		    attributes <- OrderedSet{positionname,positionvalue},
		    targetModel <- thisModule.m_constraint 	
		),
		positionname : MAPPING!ExpressionAttribute(
		    name <- 'name',
		    value <- '\'position\''
	    ),
		positionvalue : MAPPING!ExpressionAttribute(
		    name <- 'value',
		    value <- constraintname + 'position'
	    )
	do {
	    positionfeature;	
	}	
}

--Rule making link equation for given constraint, attribute and variable and disambiguated by rank
rule makeEquation(constraintname : String, attributename : String, variablename : String, rank : String) {
    using {
	    temp : OrderedSet(MAPPING!TargetElement) = OrderedSet{};
	}
    to 
	    --Main equation element
		equation :  MAPPING!TargetElement (
			name <- 'Equation',
			varName <- constraintname + attributename + 'varequation',
			attributes <- OrderedSet{lefteqattr,righteqattr},
		    targetModel <- thisModule.m_constraint
		),
		lefteqattr : MAPPING!ExpressionAttribute(
			name <- 'left',
			value <- constraintname + attributename + 'expvarref'
		),
		target : MAPPING!TargetElement(
	        name <- 'VariableReference',
		    varName <- constraintname + attributename + 'expvarref',
		    attributes <- leftvariable,
		    targetModel <- thisModule.m_constraint
	    ),
		--Link to attribute
	    leftvariable : MAPPING!ExpressionAttribute(
	        name <- 'var',
	        value <- attributename + 'variablevar'
	    ),
		--Link to variable
		righteqattr : MAPPING!ExpressionAttribute(
			name <- 'right',
			value <- constraintname + attributename + 'expressionvar'
		),
		rightexp : MAPPING!TargetElement(
	        name <- 'VariableReference',
		    varName <- constraintname + attributename + 'expressionvar',
		    attributes <- variable,
		    targetModel <- thisModule.m_constraint
	    ),
	    variable : MAPPING!ExpressionAttribute(
	       name <- 'var',
	       value <- constraintname + 'variable' + variablename.substring(2,variablename.size())
	    )
	do {
	   temp <- temp.append(equation);
	   temp <- temp.append(target);
	   temp <- temp.append(rightexp);
	   temp; 
	}
}

--Rule creating initialization for local variable for given attribute attr of rule target for constraint constraint
rule initLocalVariable(target : TYPERULES!TypeRule, attr : TYPERULES!AttributeExpression, constraint : String){
	to
	--Main element
	initconstraint : MAPPING!TargetElement(
	   	name <- 'EquationConstraint',
		varName <- constraint + attr.myattribute.name + 'init',
		attributes <- OrderedSet{nameattr,comparisonattr},
		targetModel <- thisModule.m_constraint
	),
	nameattr : MAPPING!ExpressionAttribute(
	    name <- 'name',
		value <- '\'init\''
	),	
	comparisonattr : MAPPING!ExpressionAttribute(
	    name <- 'equation',
		value <- constraint + attr.myattribute.name + 'initcomp'
	),
	comparison : MAPPING!TargetElement(
	   	name <- 'Equation',
		varName <- constraint + attr.myattribute.name + 'initcomp',
		attributes <- OrderedSet{lhs,rhs,op},
		targetModel <- thisModule.m_constraint
	),
	--Link to local variable
	lhs : MAPPING!ExpressionAttribute(
	    name <- 'left',
		value <- constraint + attr.myattribute.name + 'expvarref'
	),
	varref : MAPPING!TargetElement(
        name <- 'VariableReference',
	    varName <- constraint + attr.myattribute.name + 'expvarref',
	    attributes <- variable,
	    targetModel <- thisModule.m_constraint
    ),
    variable : MAPPING!ExpressionAttribute(
        name <- 'var',
        value <- if (attr.variable.eContainer().oclIsTypeOf(TYPERULES!Generator)) then thisModule.makeFoldLocalVariable(attr.variable,'target').varName else constraint + 'variable' + attr.variable.varname.substring(2,attr.variable.varname.size()) endif 
    ),
	--Link to attribute expression
	rhs : MAPPING!ExpressionAttribute(
	    name <- 'right',
		value <- 'if (not invar.' + attr.myattribute.name + '.oclIsUndefined()) then ' + 
		         if (attr.myattribute.upperBound <> 1) 
			     then 
				     if (attr.myattribute.oclIsKindOf(ECORE!EAttribute)) 
		             then 'thisModule.makeListNode(invar.' +  attr.myattribute.name + '->collect(a | thisModule.makeLiteral(a)))' 
				     else 'thisModule.makeListNode(invar.' +  attr.myattribute.name + '->collect(o | thisModule.makeObjectNode(o)))'  
					 endif  
		         else 
		             if (attr.myattribute.oclIsKindOf(ECORE!EAttribute)) 
		             then 'thisModule.makeLiteral(invar.' + attr.myattribute.name +')' 
				     else 'thisModule.makeObjectNode(invar.' + attr.myattribute.name +')' 
					 endif 
			     endif
				 + 'else OclUndefined endif'
	),
	op : MAPPING!ExpressionAttribute(
	    name <- 'operation',
		value <- '#Equal'
	)
	do {
		OrderedSet{initconstraint,comparison,varref};
	}		    
}

--Rule building constraint handling containment relation for given variable container of rule target for constraint constraint
rule makeContainer(target : TYPERULES!TypeRule, container : TYPERULES!ContainmentVariable, constraint : String){
	to
	--Main element
	initconstraint : MAPPING!TargetElement(
	   	name <- 'EquationConstraint',
		varName <- constraint + container.container.name + 'init',
		attributes <- OrderedSet{nameattr,comparisonattr},
		targetModel <- thisModule.m_constraint
	),
	nameattr : MAPPING!ExpressionAttribute(
	    name <- 'name',
		value <- '\'container\''
	),	
	comparisonattr : MAPPING!ExpressionAttribute(
	    name <- 'equation',
		value <- constraint + container.container.name + 'initcomp'
	),
	comparison : MAPPING!TargetElement(
	   	name <- 'Equation',
		varName <- constraint + container.container.name + 'initcomp',
		attributes <- OrderedSet{lhs,rhs,op},
		targetModel <- thisModule.m_constraint
	),
	--Link to container variable
	lhs : MAPPING!ExpressionAttribute(
	    name <- 'left',
		value <- constraint + container.container.name + 'expvarref'
	),
	varref : MAPPING!TargetElement(
        name <- 'VariableReference',
	    varName <- constraint + container.container.name + 'expvarref',
	    attributes <- variable,
	    targetModel <- thisModule.m_constraint
    ),
    variable : MAPPING!ExpressionAttribute(
        name <- 'var',
        value <- constraint + 'variable' + container.varname.substring(2,container.varname.size())
    ),
	--Expression defining containment relation
	rhs : MAPPING!ExpressionAttribute(
	    name <- 'right',
		value <- 'let parent : ECORE!EObject = thisModule.getContainer(invar,\''+ container.container.name +'\') in if parent.oclIsUndefined() then OclUndefined else thisModule.makeObjectNode(parent) endif'
	),
	op : MAPPING!ExpressionAttribute(
	    name <- 'operation',
		value <- '#Equal'
	)
	do {
		OrderedSet{initconstraint,comparison,varref};
	}		    
}

--Main rule building constraint for given condition, expression expvarname and constraint constraintname using environment env
rule ConditionConstraint(source : TYPERULES!Condition, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		temp : OrderedSet(MAPPING!TargetElement) = if (source.oclIsTypeOf(TYPERULES!ComparisonCondition))
		                                           then thisModule.ComparisonConditionConstraint(source, expvarname, constraintname,env)
		                                           else thisModule.FoldConditionConstraint(source, expvarname, constraintname,env)
		                                           endif;
	}
	do {
	    temp;
	}	
}

--Rule building constraint for given comparison condition, expression expvarname and constraint constraintname using environment env
rule ComparisonConditionConstraint(source : TYPERULES!ComparisonCondition, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		--Lists of constraints for left and right subexpressions
		templeft : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.left,expvarname + 'lhs', constraintname,env);
	    tempright : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.right,expvarname + 'rhs', constraintname,env);
	    temp : OrderedSet(MAPPING!TargetElement) = templeft.union(tempright);
	}
	to
	--Main constraint element
	constraint : MAPPING!TargetElement(
	   	name <- 'EquationConstraint',
		varName <- expvarname,
		attributes <- OrderedSet{nameattr,comparisonattr},
		targetModel <- thisModule.m_constraint
	),
	nameattr : MAPPING!ExpressionAttribute(
	    name <- 'name',
		value <- '\'comparison\''
	),
	comparisonattr : MAPPING!ExpressionAttribute(
	    name <- 'equation',
		value <- expvarname + 'comparisonvar'
	),
	comparison : MAPPING!TargetElement(
	   	name <- 'Equation',
		varName <- expvarname + 'comparisonvar',
		attributes <- OrderedSet{lhs,rhs,op},
		targetModel <- thisModule.m_constraint
	),
	--Link to left subexpression
	lhs : MAPPING!ExpressionAttribute(
	    name <- 'left',
		value <- expvarname + 'lhs'
	),
	--Link to right subexpression
	rhs : MAPPING!ExpressionAttribute(
	    name <- 'right',
		value <- expvarname + 'rhs'
	)
	,
	op : MAPPING!ExpressionAttribute(
	    name <- 'operation',
		value <- '#' + source.operator
	)
	do {
		temp <- temp.prepend(comparison);
		temp <- temp.prepend(constraint);
		temp;
	}	
}

--Rule building constraint for given fold condition, expression expvarname and constraint constraintname using environment env
rule FoldConditionConstraint(source : TYPERULES!FoldCondition, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		--Set up environment with fold variables
		varlist : OrderedSet(TYPERULES!Variable) = source.generator->collect(g | g.variable).flatten();
	    newenv : Map(String,String) = varlist->iterate(v; basenv : Map(String,String) = env | Map{(v.varname,expvarname + 'variable' + v.varname.substring(2,v.varname.size()))}.union(basenv));
	}
	to
	--Main element
	constraint : MAPPING!TargetElement(
	   	name <- 'FoldConstraint',
		varName <- expvarname,
		--attributes <- OrderedSet{containerattr,variableattr,constraintattr},
		attributes <- OrderedSet{nameattr,containerattr, variableattr,constraintattr},
		targetModel <- thisModule.m_constraint
	),
	nameattr : MAPPING!ExpressionAttribute(
	    name <- 'name',
		value <- '\'fold\''
	),
	--Build container constraints
	containerattr : MAPPING!ExpressionAttribute(
	    name <- 'containers',
		value <- 'OrderedSet{' + thisModule.serialize(source.generator->select(g | not g.container.oclIsUndefined())->collect(g | expvarname + g.variable.first().varname.substring(2,g.variable.first().varname.size()) + 'generator'))  + '}'
	),
	--Build local variable constraints
	variableattr : MAPPING!ExpressionAttribute(
	    name <- 'localvariables',
		value <- 'OrderedSet{' + thisModule.serialize(source.generator->select(g | g.container.oclIsUndefined())->collect(g | g.variable->collect(v | expvarname + 'variable' + v.varname.substring(2,v.varname.size()))).flatten())  + '}'
	),
	--Build condition constraints
	constraintattr : MAPPING!ExpressionAttribute(
	    name <- 'localconstraints',
		value <- 'OrderedSet{' + thisModule.serialize(source.condition->collect(c | expvarname + 'localconstraint' + source.condition.indexOf(c))) + '}'
	)
	
	
	do {
		OrderedSet{constraint
			      ,source.generator->select(g | not g.container.oclIsUndefined())->collect(g | thisModule.makeGenerator(g,expvarname, constraintname,env))
                  ,source.generator->select(g | g.container.oclIsUndefined())->collect(g | g.variable->collect(v | thisModule.makeLocalVariableCopy(v, expvarname)))
				  ,source.condition->collect(c | thisModule.ConditionConstraint(c,expvarname + 'localconstraint' + source.condition.indexOf(c), constraintname,newenv))};
	}
}

--Rule building constraint for generator generator in expression expvarname, constraint constraintname and using enviroment env
rule makeGenerator(generator : TYPERULES!Generator, expvarname : String, constraintname : String, env : Map(String,String)) {
	to
	--Main element
	constraintgen : MAPPING!TargetElement(
	   	name <- 'Generator',
		varName <- expvarname + generator.variable.first().varname.substring(2,generator.variable.first().varname.size()) + 'generator',
		attributes <- OrderedSet{variableattr,containerattr},
		targetModel <- thisModule.m_constraint
	),
	containerattr : MAPPING!ExpressionAttribute(
	    name <- 'container',
		value <- expvarname + generator.container.target.varname.substring(2,generator.container.target.varname.size()) + 'target'
	),
	target : MAPPING!TargetElement(
	    name <- 'VariableReference',
		varName <- expvarname + generator.container.target.varname.substring(2,generator.container.target.varname.size()) + 'target',
		attributes <- variable,
		targetModel <- thisModule.m_constraint
	   ),
	--Variable to contain generated elements
	variable : MAPPING!ExpressionAttribute(
	   name <- 'var',
	   value <- env.get(generator.container.target.varname)
	),
	variableattr : MAPPING!ExpressionAttribute(
	    name <- 'variables',
		value <- 'OrderedSet{' + thisModule.serialize(generator.variable->collect(v | expvarname + 'variable' + v.varname.substring(2,v.varname.size())))  + '}'
	)
	do {
		OrderedSet{
		    constraintgen,
			target,
			generator.variable->collect(v | thisModule.makeLocalVariableCopy(v, expvarname))
		};
	}
}

--Main rule building constraint expressions for type system expressions
rule ExpressionConstraint(source : TYPERULES!Expression, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
	    temp : OrderedSet(MAPPING!TargetElement) = if source.oclIsTypeOf(TYPERULES!VariableReference)
	    	                                       then thisModule.VariableExpressionConstraint(source, expvarname, constraintname,env)
												   else if source.oclIsTypeOf(TYPERULES!TypeReference)
												        then thisModule.TypeReferenceExpressionConstraint(source, expvarname, constraintname,env)
														else if source.oclIsTypeOf(TYPERULES!SetExpression)
														     then thisModule.SetExpressionConstraint(source, expvarname, constraintname,env)
														     else if source.oclIsTypeOf(TYPERULES!FunctionReference)
														     	  then thisModule.FunctionReferenceExpressionConstraint(source, expvarname, constraintname)
																  else if source.oclIsTypeOf(TYPERULES!ModelElementExpression)
																	   then thisModule.ModelElementExpressionConstraint(source, expvarname, constraintname,env)
																       else if source.oclIsTypeOf(TYPERULES!UnaryExpression)
																			then thisModule.UnaryExpressionConstraint(source, expvarname, constraintname,env)
																			else if source.oclIsTypeOf(TYPERULES!BinaryExpression)
																				 then thisModule.BinaryExpressionConstraint(source, expvarname, constraintname,env)
																				 else if source.oclIsTypeOf(TYPERULES!StringLiteral)
																				 	  then thisModule.StringLiteralConstraint(source, expvarname, constraintname)
																					  else if source.oclIsTypeOf(TYPERULES!Number)
																					       then thisModule.NumberConstraint(source, expvarname, constraintname)
																					       else if source.oclIsTypeOf(TYPERULES!NullLiteral) 
																					       	    then thisModule.NullLiteralConstraint(source, expvarname, constraintname)
																								else thisModule.ExpressionConstraint(source.expression, expvarname, constraintname,env)
																							    endif
																						   endif
																					  endif
																				 endif
																			endif
																	   endif
																  endif
															 endif
														endif
												   endif;	
	}
	do {
	    temp;
	}
}

--Main rule building constraint expressions for binary type system expressions for expression expvarname and constraint constraintname using environment env
rule BinaryExpressionConstraint(source : TYPERULES!BinaryExpression, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
	    temp : OrderedSet(MAPPING!TargetElement) = if source.operator = #Projection 
		                                           then thisModule.BinaryExpressionProjectionConstraint(source,expvarname,constraintname,env)
		                                           else thisModule.BinaryExpressionBasicConstraint(source,expvarname,constraintname,env)
		                                           endif;
	}
	do {
		temp;
	}
}

--Rule building constraint expressions for basic binary type system expressions
rule BinaryExpressionBasicConstraint(source : TYPERULES!BinaryExpression, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		--Built constraints for left expression
	    temp : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.left,expvarname + 'left',constraintname,env);
	}
	to
	--Main element
	target : MAPPING!TargetElement(
	    name <- 'BinaryNode',
		varName <- expvarname,
		attributes <- OrderedSet{operator,left,right},
		targetModel <- thisModule.m_constraint
	   ),
	operator : MAPPING!ExpressionAttribute(
	   name <- 'operation',
	   value <- '#' + source.operator.toString()
	  ),
	left : MAPPING!ExpressionAttribute(
	   name <- 'left',
	   value <- expvarname + 'left'
	  ),
	right : MAPPING!ExpressionAttribute(
	   name <- 'right',
	   value <- expvarname + 'right'
	  )	  
	do {
		--Add constraints for right expression
		temp <- temp.union(thisModule.ExpressionConstraint(source.right,expvarname + 'right',constraintname,env)).prepend(target);
		temp;
	}
}

--Rule building constraint expressions for projection binary type system expressions for expression expvarname and constraint constraintname using environment env
rule BinaryExpressionProjectionConstraint(source : TYPERULES!BinaryExpression, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		--Built constraints for left expression
	    temp : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.left,expvarname + 'left',constraintname,env);
	}
	to
	target : MAPPING!TargetElement(
	    name <- 'IndirectReference',
		varName <- expvarname,
		attributes <- OrderedSet{name, left},
		targetModel <- thisModule.m_constraint
	   ),
	--Right expression must be a function reference
	name : MAPPING!ExpressionAttribute(
	   name <- 'name',
	   value <- '\'' + source.right.function + '\''
	  ),  
	left : MAPPING!ExpressionAttribute(
	   name <- 'expression',
	   value <- expvarname + 'left'
	  )
	do {
		temp <- temp.prepend(target);
		temp;
	}
}

--Rule building constraint expressions for unary type system expressions for expression expvarname and constraint constraintname using environment env
rule UnaryExpressionConstraint(source : TYPERULES!UnaryExpression, expvarname : String, constraintname : String, env : Map(String,String)){
	using {
		--Built subexpression
	    temp : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.left,expvarname + 'left',constraintname,env);
	}
	to 
	target : MAPPING!TargetElement(
	    name <- 'UnaryNode',
		varName <- expvarname,
		attributes <- OrderedSet{operator,left},
		targetModel <- thisModule.m_constraint
	   ),
	operator : MAPPING!ExpressionAttribute(
	   name <- 'operator',
	   value <- '#' + source.operator.toString()
	  ),
	left : MAPPING!ExpressionAttribute(
	   name <- 'left',
	   value <- expvarname + 'left'
	  )
	do {
		temp <- temp.prepend(target);
		temp;
	}
}

--Rule building constraint expressions for variable type system expressions for expression expvarname and constraint constraintname using environment env
rule VariableExpressionConstraint(source : TYPERULES!VariableReference, expvarname : String, constraintname : String, env : Map(String,String)){
	to 
	target : MAPPING!TargetElement(
	    name <- 'VariableReference',
		varName <- expvarname,
		attributes <- variable,
		targetModel <- thisModule.m_constraint
	   ),
	variable : MAPPING!ExpressionAttribute(
	   name <- 'var',
	   --Get variable reference from environment
	   value <- env.get(source.target.varname)
	  )
	do {
		OrderedSet{target};
	}
}

--Rule building constraint expressions for type reference type system expressions for expression expvarname and constraint constraintname using environment env
rule TypeReferenceExpressionConstraint(source : TYPERULES!TypeReference, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
		--Built feature elements
	    temp : OrderedSet(MAPPING!TargetElement) = source.arguments->collect(attr | thisModule.TypeReferenceElementtoFeature(attr,source.target,expvarname + source.arguments.indexOf(attr),constraintname,env)).flatten();
	}
	to 
	target : MAPPING!TargetElement(
	    name <- 'ObjectNode',
		varName <- expvarname,
		attributes <- OrderedSet{typename,typefeatures},
		targetModel <- thisModule.m_constraint
	),
	typename : MAPPING!ExpressionAttribute(
		name <- 'name',
		value <- '\'' + source.target.representation->any(r | r.relation <> #OUT).targetclass.name + '\''
	),
	typefeatures : MAPPING!ExpressionAttribute(
	    name <- 'features',
	    value <- 'OrderedSet{' + thisModule.serialize(source.arguments->collect(s | expvarname + source.arguments.indexOf(s))) + '}'
	)
	do {
		temp <- temp.prepend(target);
		temp;
		}   
}

--Rule building features for attribute of type reference source of type type for expression expvarname and constraint constraintname using environment env
rule TypeReferenceElementtoFeature(source : TYPERULES!TypeReferenceElement, type : TYPERULES!TypeDec, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
		--Get attribute name
	    attrname : String = type.representation->any(r | r.relation <> #OUT).attributes.at(type.attributes.indexOf(type.attributes->any(ta| ta.name = source.typeattribute.name))).name;
	    --Built constraint for attribute expression
		temp : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.value,expvarname + attrname + 'value', constraintname,env);
	}
	to
	target : MAPPING!TargetElement(
	    name <- 'Feature',
		varName <- expvarname,
		attributes <- OrderedSet{name,value},
		targetModel <- thisModule.m_constraint
	),
	name : MAPPING!ExpressionAttribute(
	   name <- 'name',
	   value <- '\'' + attrname + '\''
	),
	value : MAPPING!ExpressionAttribute(
	   name <- 'value',
	   value <- expvarname + attrname + 'value'
	)
	do {
		temp <- temp.prepend(target);
		temp;
	}
}

--Rule building constraint expressions for function reference type system expressions for expression expvarname and constraint constraintname using environment env
rule FunctionReferenceExpressionConstraint(source : TYPERULES!FunctionReference, expvarname : String, constraintname : String) {
	to
	--Function references are implemented as straight literals
	target : MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- expvarname,
		attributes <- type,
		targetModel <- thisModule.m_constraint
	   ),
	type : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- '\'' + source.function + '\''
	)
	do {
		OrderedSet{target};
	}   
}

--Rule building constraint expressions for set expression type system expressions for expression expvarname and constraint constraintname using environment env
rule SetExpressionConstraint(source : TYPERULES!SetExpression, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
		--Built expressions for set values
	    temp : OrderedSet(MAPPING!TargetElement) = source.values->collect(vs | thisModule.ExpressionConstraint(vs, expvarname + source.values.indexOf(vs), constraintname,env));
	}
	to
	target : MAPPING!TargetElement(
	    name <- 'ListNode',
		varName <- expvarname,
		attributes <- variable,
		targetModel <- thisModule.m_constraint
	   ),
	variable : MAPPING!ExpressionAttribute(
	   name <- 'values',
	   value <- 'OrderedSet{' + thisModule.serialize(source.values->collect(s | expvarname + source.values.indexOf(s)))  + '}'
	)
	do {
		temp <- temp.prepend(target);
		temp;
	} 
	
}

--Rule building constraint expressions for String literal type system expressions for expression expvarname and constraint constraintname using environment env
rule StringLiteralConstraint(source : TYPERULES!StringLiteralReference, expvarname : String, constraintname : String) {
	to
	--Literals are implement as literals
	target : MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- expvarname,
		attributes <- type,
		targetModel <- thisModule.m_constraint
	   ),
	--Add quotes to prevent parse errors
	type : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- '\'' + source.value + '\''
	)
	do {
		OrderedSet{target};
	}   	
}

--Rule building constraint expressions for type number expressions type system expressions for expression expvarname and constraint constraintname using environment env
rule NumberConstraint(source : TYPERULES!Number, expvarname : String, constraintname : String) {
	to
	--Literals are implemented as literals
	target : MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- expvarname,
		attributes <- type,
		targetModel <- thisModule.m_constraint
	   ),
	--Add quotes to prevent parse errors
	type : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- '\'' + source.value.toString() + '\''
	)
	do {
		OrderedSet{target};
	}   	
}

--Main rule building constraint expressions for model element type system expressions for expression expvarname and constraint constraintname using environment env
rule ModelElementExpressionConstraint(source : TYPERULES!ModelElementExpression, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
	    temp : OrderedSet(MAPPING!TargetElement) = if (not source.baseclass.oclIsKindOf(ECORE!EClass))
		                                           then thisModule.EnumerationLiteralConstraint(source,expvarname,constraintname,env)
		                                           else thisModule.ObjectExpressionConstraint(source,expvarname,constraintname,env)
		                                           endif;
	}
    do {
        temp;
    }	
}

--Rule building constraint expressions for enueration literal type system expressions for expression expvarname and constraint constraintname using environment env
rule EnumerationLiteralConstraint(source : TYPERULES!ModelElementExpression, expvarname : String, constraintname : String) {
	to
	--Literals implemented as literals
	target : MAPPING!TargetElement(
	    name <- 'Literal',
		varName <- expvarname,
		attributes <- type,
		targetModel <- thisModule.m_constraint
	   ),
	type : MAPPING!ExpressionAttribute(
		name <- 'value',
		value <- '\'' + source.baseclass.name + '\''
	)
	do {
		OrderedSet{target};
	}   	
}

--Rule building constraint expressions for object expression type system expressions for expression expvarname and constraint constraintname using environment env
rule ObjectExpressionConstraint(source : TYPERULES!ModelElementExpression, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
		--Built attribute constraints
	    temp : OrderedSet(MAPPING!TargetElement) = source.attributes->collect(attr | thisModule.AttributeExpressionToFeature(attr,expvarname + source.attributes.indexOf(attr),constraintname,env)).flatten();
	}
	to
	target : MAPPING!TargetElement(
	    name <- 'ObjectNode',
		varName <- expvarname,
		attributes <- OrderedSet{name,features},
		targetModel <- thisModule.m_constraint
	),
	name : MAPPING!ExpressionAttribute(
	    name <- 'name',
	    value <- '\'' + source.baseclass.eContainer().name + '_' + source.baseclass.name + '\''
	),
	features : MAPPING!ExpressionAttribute(
	    name <- 'features',
	    value <- 'OrderedSet{' + thisModule.serialize(source.attributes->collect(s | expvarname + source.attributes.indexOf(s)))  + '}'
	)
	do {
		temp <- temp.prepend(target);
		temp;
	} 
	
}

--Rule building constraint expressions for null literal type system expressions for expression expvarname and constraint constraintname using environment env
rule NullLiteralConstraint(source : TYPERULES!NullLiteral, expvarname : String, constraintname : String) {
	to
	--For technical reasons, null literals are object nodes
	target : MAPPING!TargetElement(
	    name <- 'ObjectNode',
		varName <- expvarname,
		attributes <- OrderedSet{typename},
		targetModel <- thisModule.m_constraint
	),
	typename : MAPPING!ExpressionAttribute(
		name <- 'name',
		value <- '\'OclUndefined\''
	)
	do {
		OrderedSet{target};
		}   
}

--Rule building constraints for attribute expression source in expression expvarname, constraint constraintname using environment env
rule AttributeExpressionToFeature(source : TYPERULES!AttributeExpression, expvarname : String, constraintname : String, env : Map(String,String)) {
	using {
		--Built subexpression
	    temp : OrderedSet(MAPPING!TargetElement) = thisModule.ExpressionConstraint(source.value,expvarname + source.myattribute.name + 'value', constraintname,env);
	}
    to
	target : MAPPING!TargetElement(
	    name <- 'Feature',
		varName <- expvarname,
		attributes <- OrderedSet{name,value},
		targetModel <- thisModule.m_constraint
	),
	name : MAPPING!ExpressionAttribute(
	   name <- 'name',
	   value <- '\'' + source.myattribute.name + '\''
	),
	value : MAPPING!ExpressionAttribute(
	   name <- 'value',
	   value <- expvarname + source.myattribute.name + 'value'
	)
	do {
		temp <- temp.prepend(target);
		temp;
	}
}

--Lazy rule building local variable for given variable source and constraint constraintname
lazy rule makeLocalVariable {
   from
       source : TYPERULES!Variable,
	   constraintname : String
	   
   to
       target : MAPPING!TargetElement(
       	   name <- 'Variable',
		   varName <- (constraintname + 'variable' + source.varname.substring(2,source.varname.size())),
		   attributes <- number,
		   targetModel <- thisModule.m_constraint
       ),
	   number : MAPPING!ExpressionAttribute(
	   	   name <- 'number',
		   value <- thisModule.createLocalIdentifier().toString()
	   )
}

--Lazy rule building local variable  copy of given fold variable source and constraint constraintname
lazy rule makeLocalVariableCopy {
   from
       source : TYPERULES!Variable,
	   constraintname : String
	   
   to
       target : MAPPING!TargetElement(
       	   name <- 'Variable',
		   varName <- (constraintname + 'variable' + source.varname.substring(2,source.varname.size())),
		   attributes <- number,
		   targetModel <- thisModule.m_constraint
       ),
	   number : MAPPING!ExpressionAttribute(
	   	   name <- 'number',
		   value <- thisModule.makeFoldLocalVariable(source,constraintname).attributes.first().value
	   )
}

--Lazy rule building unique local variable instance for given variable source and constraint constraintname
unique lazy rule makeFoldLocalVariable {
   from
       source : TYPERULES!Variable,
	   constraintname : String
	   
   to
       target : MAPPING!TargetElement(
       	   name <- 'Variable',
		   varName <- (constraintname + 'variable' + source.varname.substring(2,source.varname.size())),
		   attributes <- number,
		   targetModel <- thisModule.m_constraint
       ),
	   number : MAPPING!ExpressionAttribute(
	   	   name <- 'number',
		   value <- thisModule.createLocalIdentifier().toString()
	   )
}

--Helper keeping track of last used local variable identifier
helper def : lastlocalidentifier : Integer = 0;

--Rule updating last used local variable identifier
rule createLocalIdentifier(){
	do {
		thisModule.lastlocalidentifier <- thisModule.lastlocalidentifier + 1;
		thisModule.lastlocalidentifier; 
	}		
}